<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Retro Snake ‚Äì single file</title>
<style>
  :root {
    --bg:#0b0e14;
    --grid:#1b2030;
    --snake:#42ff87;
    --snake-dark:#2bd66a;
    --food:#ff4d6d;
    --text:#c7d0e0;
    --accent:#7aa2ff;
    --btn:#151a26;
    --btn-border:#2b3347;
  }
  html,body{height:100%;margin:0}
  body{
    background: radial-gradient(1200px 800px at 70% -10%, #141a26 0%, var(--bg) 55%) fixed;
    color:var(--text);
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    display:flex; align-items:center; justify-content:center;
  }
  .wrap{
    width:min(96vw,720px); max-width:720px; padding:16px;
    display:grid; gap:14px; grid-template-rows:auto 1fr auto;
    background:rgba(10,13,20,.55);
    border:1px solid #1d2333; border-radius:18px; box-shadow:0 12px 30px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.03);
  }
  header{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
  }
  .title{
    font-weight:800; letter-spacing:.5px;
    background:linear-gradient(90deg, var(--accent), #92fbff 60%, #fff);
    -webkit-background-clip:text; background-clip:text; color:transparent;
    text-shadow:0 0 8px rgba(122,162,255,.25);
  }
  .stats{display:flex; gap:12px; align-items:baseline; flex-wrap:wrap}
  .chip{
    background:rgba(21,26,38,.75);
    border:1px solid var(--btn-border);
    padding:6px 10px; border-radius:10px; font-size:14px; line-height:1;
  }
  .buttons{display:flex; gap:8px; flex-wrap:wrap}
  button{
    background:var(--btn);
    border:1px solid var(--btn-border);
    color:var(--text);
    padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700;
    transition:transform .06s ease, background .15s ease, border-color .2s;
  }
  button:hover{transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  #gameBox{
    display:grid; place-items:center;
    background:
      linear-gradient(90deg, transparent 24px, var(--grid) 25px, transparent 26px) 0 0/26px 26px,
      linear-gradient(transparent 24px, var(--grid) 25px, transparent 26px) 0 0/26px 26px,
      radial-gradient(900px 400px at 50% -40%, rgba(122,162,255,.12), transparent 60%),
      rgba(12,14,22,.6);
    border:1px solid #1c2233; border-radius:14px; overflow:hidden;
    position:relative; aspect-ratio:1/1; width:100%;
  }
  canvas{image-rendering: pixelated; image-rendering: crisp-edges}
  footer{
    display:grid; gap:10px;
  }
  .touch{
    display:grid; grid-template-areas:
      ". up ."
      "left . right"
      ". down .";
    gap:8px; justify-content:center; align-content:center;
  }
  .touch button{
    width:64px; height:64px; border-radius:14px; font-size:18px;
    background:linear-gradient(180deg, #121723, #0f1320);
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.04), 0 8px 16px rgba(0,0,0,.35);
  }
  .up{grid-area:up} .down{grid-area:down} .left{grid-area:left} .right{grid-area:right}
  .muted{opacity:.8; font-size:13px}
  @media (min-width:620px){
    footer{grid-template-columns:1fr auto}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">RETRO SNAKE</div>
      <div class="stats">
        <div class="chip">Score: <span id="score">0</span></div>
        <div class="chip">High: <span id="high">0</span></div>
        <div class="buttons">
          <button id="btnPause" title="Space / P">‚è∏ Pause</button>
          <button id="btnReset" title="R">üîÑ Reset</button>
        </div>
      </div>
    </header>

    <div id="gameBox">
      <canvas id="c" width="256" height="256" aria-label="Snake game area"></canvas>
    </div>

    <footer>
      <div class="muted">Controls: Arrow Keys / WASD ‚Ä¢ Space/P = Pause ‚Ä¢ R = Reset</div>
      <div class="touch" aria-label="Touch controls">
        <button class="up"   data-dir="0,-1">‚ñ≤</button>
        <button class="left" data-dir="-1,0">‚óÄ</button>
        <button class="right"data-dir="1,0">‚ñ∂</button>
        <button class="down" data-dir="0,1">‚ñº</button>
      </div>
    </footer>
  </div>

<script>
(() => {
  // --- Config ---
  const GRID = 16;           // virtual grid size (cells per side)
  const SPEED_START = 6;     // cells per second
  const SPEED_MAX = 16;
  const GROWTH = 2;          // cells grown per food
  const WALLS = true;        // set false to wrap-around
  const SCALE_BASE = 16;     // base pixel size (auto-scaled to canvas)

  // --- State ---
  let snake, dir, nextDir, food, score, high, grow=0, speed=SPEED_START, lastTime=0, acc=0, paused=false, dead=false;

  // --- Canvas setup with crisp scaling ---
  const box = document.getElementById('gameBox');
  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  function resizeCanvas() {
    const size = Math.floor(Math.min(box.clientWidth, box.clientHeight));
    // keep canvas pixels as a multiple of GRID to preserve crispness
    const cell = Math.max(8, Math.floor(size / GRID));
    cvs.width = cell * GRID;
    cvs.height = cell * GRID;
  }
  new ResizeObserver(resizeCanvas).observe(box);

  // UI elements
  const scoreEl = document.getElementById('score');
  const highEl = document.getElementById('high');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');

  // --- Helpers ---
  const randInt = (n)=> Math.floor(Math.random()*n);
  const key = (x,y)=> `${x},${y}`;
  const set = new Set();

  function init() {
    snake = [{x:Math.floor(GRID/2), y:Math.floor(GRID/2)}];
    dir = {x:1,y:0}; nextDir = {x:1,y:0};
    grow = 3; score = 0; speed=SPEED_START; paused=false; dead=false; acc=0;
    set.clear(); snake.forEach(s=>set.add(key(s.x,s.y)));
    spawnFood();
    render(0); updateHUD();
  }

  function spawnFood() {
    let x,y;
    do { x = randInt(GRID); y = randInt(GRID); }
    while (set.has(key(x,y)));
    food = {x,y};
  }

  function updateHUD() {
    scoreEl.textContent = score;
    if (high == null) {
      high = +localStorage.getItem('retroSnakeHigh') || 0;
    }
    if (score > high) {
      high = score;
      localStorage.setItem('retroSnakeHigh', high);
    }
    highEl.textContent = high;
  }

  function step(dt) {
    if (paused || dead) return;
    acc += dt;
    const stepTime = 1/Math.min(SPEED_MAX, speed);
    while (acc >= stepTime) {
      acc -= stepTime;
      // apply queued dir (prevent 180 turn)
      if ((nextDir.x !== -dir.x) || (nextDir.y !== -dir.y)) dir = nextDir;

      const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

      // walls or wrap
      if (WALLS) {
        if (head.x<0 || head.y<0 || head.x>=GRID || head.y>=GRID) { gameOver(); break; }
      } else {
        head.x = (head.x+GRID)%GRID;
        head.y = (head.y+GRID)%GRID;
      }

      // self hit?
      if (set.has(key(head.x, head.y))) { gameOver(); break; }

      // move
      snake.unshift(head);
      set.add(key(head.x, head.y));
      let ate = (head.x===food.x && head.y===food.y);
      if (ate) {
        score += 10;
        grow += GROWTH;
        speed = Math.min(SPEED_MAX, speed + 0.25);
        spawnFood();
        updateHUD();
        flash(food.x, food.y);
      }
      if (grow>0) {
        grow--;
      } else {
        const tail = snake.pop();
        set.delete(key(tail.x, tail.y));
      }
    }
  }

  // simple flash particle when eating
  let flashTicks=0, flashPos=null;
  function flash(x,y){ flashTicks=8; flashPos={x,y}; }

  function render() {
    const cw = cvs.width/GRID, ch = cvs.height/GRID;

    // bg clear
    ctx.fillStyle = "#0d1220";
    ctx.fillRect(0,0,cvs.width,cvs.height);

    // food
    ctx.fillStyle = getCss('--food');
    roundRect(food.x*cw+2, food.y*ch+2, cw-4, ch-4, 4, true);

    // snake body
    for (let i = snake.length-1; i>=0; i--) {
      const s = snake[i];
      const x = s.x*cw, y = s.y*ch;
      ctx.fillStyle = i%2 ? getCss('--snake-dark') : getCss('--snake');
      roundRect(x+2, y+2, cw-4, ch-4, 5, true);
    }

    // head shine
    const h = snake[0];
    ctx.fillStyle = "rgba(255,255,255,.15)";
    ctx.fillRect(h.x*cw+4, h.y*ch+4, Math.max(2, cw/4), Math.max(2, ch/4));

    // flash effect
    if (flashTicks>0 && flashPos){
      ctx.globalAlpha = flashTicks/8;
      ctx.strokeStyle = "white";
      ctx.lineWidth = Math.max(1, cw/12);
      ctx.strokeRect(flashPos.x*cw+3, flashPos.y*ch+3, cw-6, ch-6);
      ctx.globalAlpha = 1;
      flashTicks--;
    }

    // overlay texts
    if (paused || dead){
      ctx.fillStyle = "rgba(0,0,0,.45)";
      ctx.fillRect(0,0,cvs.width,cvs.height);
      banner(paused ? "PAUSED" : "GAME OVER", paused ? "Space/P to resume" : "R to restart");
    }
  }

  function banner(main, sub){
    const midX = cvs.width/2;
    ctx.fillStyle = "#e6f0ff";
    ctx.font = `bold ${Math.floor(cvs.width/10)}px ui-monospace`;
    ctx.textAlign="center";
    ctx.fillText(main, midX, cvs.height/2);
    ctx.fillStyle = "rgba(230,240,255,.8)";
    ctx.font = `bold ${Math.floor(cvs.width/24)}px ui-monospace`;
    ctx.fillText(sub, midX, cvs.height/2 + cvs.height/12);
  }

  function roundRect(x,y,w,h,r,fill){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
    if (fill) ctx.fill();
  }

  function getCss(varName) {
    return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  }

  function gameOver(){
    dead = true;
  }

  // --- Loop ---
  function loop(ts){
    const dt = Math.min(0.1, (ts - lastTime)/1000 || 0);
    lastTime = ts;
    step(dt);
    render();
    requestAnimationFrame(loop);
  }

  // --- Input ---
  const DIRS = {
    ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1}, ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0},
    w:{x:0,y:-1}, s:{x:0,y:1}, a:{x:-1,y:0}, d:{x:1,y:0},
    W:{x:0,y:-1}, S:{x:0,y:1}, A:{x:-1,y:0}, D:{x:1,y:0}
  };

  window.addEventListener('keydown', (e)=>{
    if (DIRS[e.key]) {
      e.preventDefault();
      const nd = DIRS[e.key];
      // prevent instant reverse by queueing
      if (!(nd.x === -dir.x && nd.y === -dir.y)) nextDir = nd;
    } else if (e.key === ' ' || e.key.toLowerCase() === 'p') {
      e.preventDefault(); paused = !paused;
      btnPause.textContent = paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
    } else if (e.key.toLowerCase() === 'r') {
      e.preventDefault(); init();
    }
  }, {passive:false});

  // Touch controls
  document.querySelectorAll('.touch button').forEach(b=>{
    b.addEventListener('click', ()=>{
      const [x,y] = b.dataset.dir.split(',').map(Number);
      const nd = {x,y};
      if (!(nd.x === -dir.x && nd.y === -dir.y)) nextDir = nd;
    });
  });

  btnPause.addEventListener('click', ()=>{ paused=!paused; btnPause.textContent = paused ? '‚ñ∂ Resume' : '‚è∏ Pause'; });
  btnReset.addEventListener('click', ()=> init());

  // Kickoff
  resizeCanvas();
  init();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
